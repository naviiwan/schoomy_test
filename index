<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>スクーミー ボタン → カウントアップ</title>
  <style>
    body { font-family: system-ui, sans-serif; padding: 20px; }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    #count { font-size: 64px; font-weight: 800; margin: 16px 0; }
    #status { padding: 6px 10px; border-radius: 999px; background: #eee; }
    #log { white-space: pre-wrap; background:#111; color:#ddd; padding:10px; border-radius: 8px; height: 140px; overflow:auto;}
    button { font-size: 16px; padding: 10px 14px; }
  </style>
</head>
<body>
  <h1>スクーミー：ボタンでカウントアップ</h1>

  <div class="row">
    <button id="connect">接続</button>
    <button id="reset">リセット</button>
    <span id="status">DISCONNECTED</span>
  </div>

  <div id="count">0</div>
  <div>入力値（最後に受信した0/1）: <span id="last">-</span></div>

  <h3>ログ</h3>
  <div id="log"></div>

<script>
let port = null;
let reader = null;

let count = 0;
let lastValue = 0;          // 前回の入力（0/1）
let lastEdgeTime = 0;       // チャタリング対策
const debounceMs = 120;     // 必要なら調整

const $ = (id) => document.getElementById(id);
const log = (msg) => { $("log").textContent += msg + "\n"; $("log").scrollTop = $("log").scrollHeight; };

function setStatus(connected) {
  $("status").textContent = connected ? "CONNECTED" : "DISCONNECTED";
  $("status").style.background = connected ? "#c8f7d2" : "#eee";
}

function render() {
  $("count").textContent = String(count);
}

$("reset").addEventListener("click", () => {
  count = 0;
  render();
});

$("connect").addEventListener("click", async () => {
  if (!("serial" in navigator)) {
    alert("このブラウザはWeb Serialに対応していません（Chrome / Edge推奨）");
    return;
  }
  if (port) return;

  try {
    port = await navigator.serial.requestPort();     // ここでユーザー操作が必要
    await port.open({ baudRate: 9600 });
    setStatus(true);
    log("接続しました");
    readLoop();
  } catch (e) {
    log("接続失敗: " + e);
    port = null;
    setStatus(false);
  }
});

async function readLoop() {
  const decoder = new TextDecoderStream();
  port.readable.pipeTo(decoder.writable);
  reader = decoder.readable.getReader();

  let buffer = "";

  try {
    while (true) {
      const { value, done } = await reader.read();
      if (done) break;
      if (!value) continue;

      buffer += value;
      let idx;
      while ((idx = buffer.indexOf("\n")) >= 0) {
        const line = buffer.slice(0, idx).trim();
        buffer = buffer.slice(idx + 1);

        const v = parseInt(line, 10);
        if (Number.isNaN(v)) continue;

        $("last").textContent = String(v);

        // 0->1 の「押した瞬間」だけカウント
        if (lastValue === 0 && v === 1) {
          const now = Date.now();
          if (now - lastEdgeTime > debounceMs) {
            count++;
            render();
            lastEdgeTime = now;
          }
        }
        lastValue = v;
      }
    }
  } catch (e) {
    log("読取エラー: " + e);
  } finally {
    setStatus(false);
    log("切断しました");
    try { reader?.releaseLock(); } catch {}
    try { await port?.close(); } catch {}
    reader = null;
    port = null;
  }
}

render();
</script>
</body>
</html>
